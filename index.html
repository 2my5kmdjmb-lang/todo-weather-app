<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Todoåº”ç”¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #ffffff;
            color: #000000;
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        .app-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .app-header h1 {
            font-size: 2.5rem;
            font-weight: 300;
            color: #000000;
        }

        .weather-widget {
            background-color: transparent;
            padding: 1.5rem 0;
            margin-bottom: 2rem;
            color: #000000;
            text-align: center;
        }

        .weather-location {
            font-size: 1.1rem;
            opacity: 0.8;
            margin-bottom: 0.5rem;
            color: #000000;
        }

        .weather-main {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin: 1rem 0;
        }

        .weather-temp {
            font-size: 3rem;
            font-weight: 300;
            color: #000000;
        }

        .weather-icon {
            font-size: 3rem;
        }

        .weather-description {
            font-size: 1.1rem;
            opacity: 0.8;
            text-transform: capitalize;
            color: #000000;
        }

        .weather-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e0e0e0;
        }

        .weather-detail {
            text-align: center;
        }

        .weather-detail-label {
            font-size: 0.9rem;
            opacity: 0.7;
            color: #000000;
        }

        .weather-detail-value {
            font-size: 1.1rem;
            font-weight: 500;
            color: #000000;
        }

        .weather-loading {
            text-align: center;
            padding: 2rem;
            color: #000000;
        }

        .weather-error {
            background: transparent;
            color: #000000;
            padding: 1rem 0;
            margin-bottom: 2rem;
            text-align: center;
        }

        .add-task-form {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
        }

        .task-input {
            flex: 1;
            padding: 1rem;
            border: 1px solid #000000;
            border-radius: 8px;
            background-color: #ffffff;
            color: #000000;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .task-input:focus {
            border-color: #000000;
            border-width: 2px;
        }

        .task-input::placeholder {
            color: #666666;
        }

        .add-button {
            padding: 1rem 1.5rem;
            background-color: #000000;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .add-button:hover {
            background-color: #333333;
        }

        .task-list-container {
            min-height: 200px;
        }

        .task-list {
            list-style: none;
        }

        .task-item {
            display: flex;
            align-items: center;
            padding: 1rem;
            margin-bottom: 0.5rem;
            background-color: #ffffff;
            border: 1px solid #000000;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .task-item:hover {
            background-color: #f8f8f8;
        }

        .task-content {
            display: flex;
            align-items: center;
            flex: 1;
            cursor: pointer;
        }

        .task-checkbox {
            width: 20px;
            height: 20px;
            margin-right: 1rem;
            cursor: pointer;
        }

        .task-label {
            flex: 1;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .task-item.completed .task-label {
            text-decoration: line-through;
            opacity: 0.5;
            color: #666666;
        }

        .delete-button {
            padding: 0.5rem;
            background-color: transparent;
            color: #000000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: background-color 0.3s ease;
        }

        .delete-button:hover {
            background-color: #f0f0f0;
        }

        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: #666666;
            display: none;
        }

        .empty-state.show {
            display: block;
        }

        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 480px) {
            .container {
                padding: 1rem 0.5rem;
            }
            
            .app-header h1 {
                font-size: 2rem;
            }
            
            .add-task-form {
                flex-direction: column;
            }
            
            .add-button {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="app-header">
            <h1>Todo & å¤©æ°”</h1>
        </header>
        
        <main class="app-main">
            <div class="weather-widget" id="weatherWidget">
                <div class="weather-loading" id="weatherLoading">
                    æ­£åœ¨è·å–å¤©æ°”ä¿¡æ¯...
                </div>
            </div>
            <form class="add-task-form" id="addTaskForm">
                <input 
                    type="text" 
                    class="task-input" 
                    id="taskInput"
                    placeholder="æ·»åŠ æ–°ä»»åŠ¡..."
                    autocomplete="off"
                >
                <button type="submit" class="add-button">æ·»åŠ </button>
            </form>
            
            <div class="task-list-container">
                <ul class="task-list" id="taskList"></ul>
                <div class="empty-state" id="emptyState">
                    <p>è¿˜æ²¡æœ‰ä»»åŠ¡ï¼Œåœ¨ä¸Šé¢æ·»åŠ ä¸€ä¸ªå¼€å§‹å§ï¼</p>
                </div>
            </div>
        </main>
    </div>

    <script>
        // å¤©æ°”ç®¡ç†å™¨
        class WeatherManager {
            constructor() {
                this.apiKey = 'demo'; // ä½¿ç”¨æ¼”ç¤ºæ•°æ®
                this.currentWeather = null;
            }

            async getCurrentWeather() {
                try {
                    // è·å–ç”¨æˆ·ä½ç½®
                    const position = await this.getCurrentPosition();
                    const { latitude, longitude } = position.coords;
                    
                    // æ¨¡æ‹Ÿå¤©æ°”æ•°æ®ï¼ˆå®é™…åº”ç”¨ä¸­åº”è¯¥è°ƒç”¨çœŸå®çš„å¤©æ°”APIï¼‰
                    const weatherData = this.getMockWeatherData(latitude, longitude);
                    this.currentWeather = weatherData;
                    return weatherData;
                } catch (error) {
                    console.error('è·å–å¤©æ°”å¤±è´¥:', error);
                    throw new Error('æ— æ³•è·å–å¤©æ°”ä¿¡æ¯');
                }
            }

            getCurrentPosition() {
                return new Promise((resolve, reject) => {
                    if (!navigator.geolocation) {
                        reject(new Error('æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†å®šä½'));
                        return;
                    }

                    navigator.geolocation.getCurrentPosition(
                        resolve,
                        (error) => {
                            switch (error.code) {
                                case error.PERMISSION_DENIED:
                                    reject(new Error('ç”¨æˆ·æ‹’ç»äº†åœ°ç†å®šä½è¯·æ±‚'));
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    reject(new Error('ä½ç½®ä¿¡æ¯ä¸å¯ç”¨'));
                                    break;
                                case error.TIMEOUT:
                                    reject(new Error('è·å–ä½ç½®è¶…æ—¶'));
                                    break;
                                default:
                                    reject(new Error('è·å–ä½ç½®æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯'));
                                    break;
                            }
                        },
                        {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 300000 // 5åˆ†é’Ÿç¼“å­˜
                        }
                    );
                });
            }

            getMockWeatherData(lat, lon) {
                // æ¨¡æ‹Ÿä¸åŒåŸå¸‚çš„å¤©æ°”æ•°æ®
                const cities = [
                    { name: 'åŒ—äº¬', temp: 22, desc: 'æ™´æœ—', icon: 'â˜€ï¸', humidity: 45, wind: 12, pressure: 1013 },
                    { name: 'ä¸Šæµ·', temp: 26, desc: 'å¤šäº‘', icon: 'â›…', humidity: 68, wind: 8, pressure: 1015 },
                    { name: 'å¹¿å·', temp: 29, desc: 'å°é›¨', icon: 'ğŸŒ§ï¸', humidity: 78, wind: 15, pressure: 1008 },
                    { name: 'æ·±åœ³', temp: 28, desc: 'é˜´å¤©', icon: 'â˜ï¸', humidity: 72, wind: 10, pressure: 1012 }
                ];
                
                const randomCity = cities[Math.floor(Math.random() * cities.length)];
                
                return {
                    location: randomCity.name,
                    temperature: randomCity.temp,
                    description: randomCity.desc,
                    icon: randomCity.icon,
                    humidity: randomCity.humidity,
                    windSpeed: randomCity.wind,
                    pressure: randomCity.pressure,
                    timestamp: new Date().toISOString()
                };
            }

            getWeatherIcon(description) {
                const iconMap = {
                    'æ™´æœ—': 'â˜€ï¸',
                    'å¤šäº‘': 'â›…',
                    'é˜´å¤©': 'â˜ï¸',
                    'å°é›¨': 'ğŸŒ§ï¸',
                    'å¤§é›¨': 'â›ˆï¸',
                    'é›ª': 'â„ï¸',
                    'é›¾': 'ğŸŒ«ï¸'
                };
                return iconMap[description] || 'ğŸŒ¤ï¸';
            }
        }

        // å¤©æ°”UIç®¡ç†å™¨
        class WeatherUIManager {
            constructor() {
                this.weatherWidget = document.getElementById('weatherWidget');
                this.weatherLoading = document.getElementById('weatherLoading');
            }

            showLoading() {
                this.weatherWidget.innerHTML = `
                    <div class="weather-loading">
                        æ­£åœ¨è·å–å¤©æ°”ä¿¡æ¯...
                    </div>
                `;
            }

            showError(message) {
                this.weatherWidget.innerHTML = `
                    <div class="weather-error">
                        ${message}
                        <br>
                        <button onclick="todoApp.loadWeather()" style="margin-top: 0.5rem; padding: 0.5rem 1rem; background: #000000; border: 1px solid #000000; border-radius: 4px; color: #ffffff; cursor: pointer;">
                            é‡è¯•
                        </button>
                    </div>
                `;
            }

            renderWeather(weather) {
                this.weatherWidget.innerHTML = `
                    <div class="weather-location">${weather.location}</div>
                    <div class="weather-main">
                        <div class="weather-temp">${weather.temperature}Â°C</div>
                        <div class="weather-icon">${weather.icon}</div>
                    </div>
                    <div class="weather-description">${weather.description}</div>
                    <div class="weather-details">
                        <div class="weather-detail">
                            <div class="weather-detail-label">æ¹¿åº¦</div>
                            <div class="weather-detail-value">${weather.humidity}%</div>
                        </div>
                        <div class="weather-detail">
                            <div class="weather-detail-label">é£é€Ÿ</div>
                            <div class="weather-detail-value">${weather.windSpeed}km/h</div>
                        </div>
                        <div class="weather-detail">
                            <div class="weather-detail-label">æ°”å‹</div>
                            <div class="weather-detail-value">${weather.pressure}hPa</div>
                        </div>
                    </div>
                `;
            }
        }
        class TaskManager {
            constructor() {
                this.tasks = new Map();
            }

            createTask(text) {
                if (!text || !text.trim()) {
                    return null;
                }
                
                const task = {
                    id: 'task-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                    text: text.trim(),
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                this.tasks.set(task.id, task);
                return task;
            }

            deleteTask(taskId) {
                return this.tasks.delete(taskId);
            }

            toggleTask(taskId) {
                const task = this.tasks.get(taskId);
                if (task) {
                    task.completed = !task.completed;
                    return task;
                }
                return null;
            }

            getAllTasks() {
                return Array.from(this.tasks.values());
            }

            getTask(taskId) {
                return this.tasks.get(taskId);
            }

            loadTasks(tasksData) {
                this.tasks.clear();
                if (Array.isArray(tasksData)) {
                    tasksData.forEach(task => {
                        this.tasks.set(task.id, task);
                    });
                }
            }
        }

        // å­˜å‚¨ç®¡ç†å™¨
        class StorageManager {
            constructor() {
                this.storageKey = 'todo-app-tasks';
            }

            saveTasks(tasks) {
                try {
                    const data = JSON.stringify(tasks);
                    localStorage.setItem(this.storageKey, data);
                    return true;
                } catch (error) {
                    console.error('ä¿å­˜ä»»åŠ¡å¤±è´¥:', error);
                    return false;
                }
            }

            loadTasks() {
                try {
                    const data = localStorage.getItem(this.storageKey);
                    return data ? JSON.parse(data) : [];
                } catch (error) {
                    console.error('åŠ è½½ä»»åŠ¡å¤±è´¥:', error);
                    return [];
                }
            }

            clearTasks() {
                try {
                    localStorage.removeItem(this.storageKey);
                    return true;
                } catch (error) {
                    console.error('æ¸…é™¤ä»»åŠ¡å¤±è´¥:', error);
                    return false;
                }
            }
        }

        // UIç®¡ç†å™¨
        class UIManager {
            constructor() {
                this.taskList = document.getElementById('taskList');
                this.emptyState = document.getElementById('emptyState');
                this.taskInput = document.getElementById('taskInput');
            }

            renderTasks(tasks) {
                this.taskList.innerHTML = '';
                
                if (tasks.length === 0) {
                    this.showEmptyState();
                    return;
                }

                this.hideEmptyState();
                tasks.forEach(task => {
                    this.renderTask(task);
                });
            }

            renderTask(task) {
                const taskItem = document.createElement('li');
                taskItem.className = `task-item fade-in ${task.completed ? 'completed' : ''}`;
                taskItem.dataset.taskId = task.id;

                taskItem.innerHTML = `
                    <div class="task-content" onclick="todoApp.handleToggleTask('${task.id}')">
                        <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''}>
                        <label class="task-label">${this.escapeHtml(task.text)}</label>
                    </div>
                    <button class="delete-button" onclick="todoApp.handleDeleteTask('${task.id}')" title="åˆ é™¤ä»»åŠ¡">
                        Ã—
                    </button>
                `;

                this.taskList.appendChild(taskItem);
            }

            updateTaskDisplay(task) {
                const taskItem = document.querySelector(`[data-task-id="${task.id}"]`);
                if (taskItem) {
                    const checkbox = taskItem.querySelector('.task-checkbox');
                    checkbox.checked = task.completed;
                    
                    if (task.completed) {
                        taskItem.classList.add('completed');
                    } else {
                        taskItem.classList.remove('completed');
                    }
                }
            }

            removeTaskFromUI(taskId) {
                const taskItem = document.querySelector(`[data-task-id="${taskId}"]`);
                if (taskItem) {
                    taskItem.remove();
                }
            }

            showEmptyState() {
                this.emptyState.classList.add('show');
            }

            hideEmptyState() {
                this.emptyState.classList.remove('show');
            }

            clearInput() {
                this.taskInput.value = '';
            }

            focusInput() {
                this.taskInput.focus();
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // ä¸»åº”ç”¨æ§åˆ¶å™¨
        class TodoApp {
            constructor() {
                this.taskManager = new TaskManager();
                this.storageManager = new StorageManager();
                this.uiManager = new UIManager();
                this.weatherManager = new WeatherManager();
                this.weatherUIManager = new WeatherUIManager();
            }

            async init() {
                // åŠ è½½ä¿å­˜çš„ä»»åŠ¡
                const savedTasks = this.storageManager.loadTasks();
                this.taskManager.loadTasks(savedTasks);
                
                // æ¸²æŸ“ä»»åŠ¡åˆ—è¡¨
                this.uiManager.renderTasks(this.taskManager.getAllTasks());
                
                // ç»‘å®šäº‹ä»¶
                this.bindEvents();
                
                // èšç„¦è¾“å…¥æ¡†
                this.uiManager.focusInput();

                // åŠ è½½å¤©æ°”ä¿¡æ¯
                await this.loadWeather();
            }

            async loadWeather() {
                try {
                    this.weatherUIManager.showLoading();
                    const weather = await this.weatherManager.getCurrentWeather();
                    this.weatherUIManager.renderWeather(weather);
                } catch (error) {
                    console.error('å¤©æ°”åŠ è½½å¤±è´¥:', error);
                    this.weatherUIManager.showError(error.message);
                }
            }

            bindEvents() {
                const form = document.getElementById('addTaskForm');
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleAddTask();
                });
            }

            handleAddTask() {
                const input = document.getElementById('taskInput');
                const text = input.value.trim();
                
                if (!text) {
                    return;
                }

                const task = this.taskManager.createTask(text);
                if (task) {
                    this.uiManager.hideEmptyState();
                    this.uiManager.renderTask(task);
                    this.uiManager.clearInput();
                    this.uiManager.focusInput();
                    this.saveToStorage();
                }
            }

            handleToggleTask(taskId) {
                const task = this.taskManager.toggleTask(taskId);
                if (task) {
                    this.uiManager.updateTaskDisplay(task);
                    this.saveToStorage();
                }
            }

            handleDeleteTask(taskId) {
                if (this.taskManager.deleteTask(taskId)) {
                    this.uiManager.removeTaskFromUI(taskId);
                    
                    // æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºç©ºçŠ¶æ€
                    const remainingTasks = this.taskManager.getAllTasks();
                    if (remainingTasks.length === 0) {
                        this.uiManager.showEmptyState();
                    }
                    
                    this.saveToStorage();
                }
            }

            saveToStorage() {
                const tasks = this.taskManager.getAllTasks();
                this.storageManager.saveTasks(tasks);
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        const todoApp = new TodoApp();
        document.addEventListener('DOMContentLoaded', async () => {
            await todoApp.init();
        });
    </script>
</body>
</html>